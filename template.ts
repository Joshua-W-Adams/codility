/**
 * Problem Solving Methodology
 *
 * - Understand the problem
 *    Read twice if necessary
 *    Draw out and visualise the logic and what happens at each step
 *    - as a loop iteration
 *    - or a dependency graph (DAG)
 *
 * - Break down the requirements
 *    Define inputs, outputs and any special output considerations
 *    Do a few basic examples
 *    Ask yourself. Are there any dependencies between inputs and results?
 *    Can these be described by algebra?
 *
 * - Pseudocode - KISS - most simple solution (brute force) first
 *    Comment the high level steps directly in function signature
 *    DO NOT proceed until this is solved
 *
 * - Tests (TDD)
 *    Usually included in testing platform already
 *
 * - Code
 *
 * - Test and Debug
 *
 * - Review
 *    time complexity
 *    space complexity
 *
 *    other more efficient solutions to problem such as:
 *
 *      for iterative problems:
 *      - can i look forward in the iteration?
 *      - can i look backward in the iteration? allowing you to store results
 *      - brute force
 *      - two pass hash map
 *      - one pass hash map
 *
 *      for dynamic programming problems:
 *      - recursive
 *      - recursive + memoized
 *      - bottom up + memoized
 *
 *    alternative programming languages?
 *    - e.g. Java: Best for performance and robust type checking.
 *    - C++: Best for performance and fine control over resources.
 */

export function solution(a: number, b: number[]) {
  return 2;
}
